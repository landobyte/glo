#!/bin/bash

# =====[ LIB : XGIT ]==========================================================
#
#	Written by Francois Joubert
#	Sep 2013
#
#	Extended git tools
#
# =============================================================================

lib xgit

lib import scrutils

# -----[ FUNCTIONS ]-----------------------------------------------------------

git_branch() {
	xgCheckoutBranchName=${1:?}

	git checkout -b $xgCheckoutBranchName --quiet
}

git_branch_new() {
	xgNewBranchName=${1:?}

	git branch $xgNewBranchName
}

git_branch_delete() {
	xgDeleteBranchName=${1:?}

	git branch --delete $xgDeleteBranchName --quiet
}

git_checkout() {
	xgCheckoutBranchName=${1:?}

	git checkout $xgCheckoutBranchName --quiet
}

git_branch_exist() {
	argo "!xgFullBranchName" "$@"

	if [[ -n $(git branch -a | grep "^[* a-z/]*$xgFullBranchName$") ]]; then
		RET=true
		return 0
	else
		RET=false
		return 1
	fi
}

git_branch_istype() {
	xgType=${1:?}

	xgResult=$(git branch | grep "^\*\ *$xgType")
	debug -2 "Result: $xgResult"
	[[ -z $xgResult ]] && return 1 
	RET=${xgResult##*/}
	debug -2 "Return: $RET"
}

git_branch_gettype() {
	xgCurrentBranch=${1:-$(git branch | grep -e "^\*")}
	xgBranchFullName=${xgCurrentBranch##* }
	TYPE=${xgBranchFullName%/*}
	TYPE=${TYPE##*/}
	case $TYPE in
		feature) SHORTTYPE=F ;;
		bug)     SHORTTYPE=B ;;
		hotfix)  SHORTTYPE=X ;;
		*)       SHORTTYPE=T ;;
	esac
	NAME=${xgBranchFullName#*/}
}

git_branch_isnewer() {
	xgCompareBranchName=${1:?}
	xgBranchName=${2:-HEAD}

	xgCompareBranchTimestamp=$(git show --no-patch --format="%ct" $xgCompareBranchName)
	xgBranchTimestamp=$(git show --no-patch --format="%ct" $xgBranchName)

	debug -2 "Isnewer: $xgCompareBranchName [$xgCompareBranchTimestamp] than $xgBranchName [$xgBranchTimestamp]"

	[[ $xgCompareBranchTimestamp > $xgBranchTimestamp ]] && return 0 || return 1
}

git_merge() {
	xgNoFastForward=--no-ff
	if [[ $1 == -ff ]]; then
		xgNoFastForward=""; shift
	fi
	xgMergeBranchName=${1:?}
	xgMergeMessage=${2:?}

	echo ">> Merging from $xgMergeBranchName..."
	xgMerge=$(git merge $xgNoFastForward -m "$xgMergeMessage" $xgMergeBranchName --quiet)
	xgMergeResult=$?
	if [[ -n $xgMerge && $xgMerge != *"up-to-date"* ]]; then
		xgMerge=${xgMerge//$'\n'/$'\n'   }
		echo -e "   $xgMerge"
	fi

	return $xgMergeResult
}

git_tag() {
	xgTagName=${1:?}
	
	echo ">> Tagging..."
	git tag --force $xgTagName
}

git_tag_exist() {
	argo "!xgTagName" "$@"
	
	if git show-ref --verify --quiet refs/tags/$xgTagName; then
		RET=true
		return 0
	else
		RET=false
		return 1
	fi
}

git_pull() {
	xgPullBranchName=${1:?}

	echo -n ">> Updating $xgPullBranchName... "
	if xgPull=$(git pull --ff-only --no-edit 2>&1); then #--quiet
		if [[ $xgPull == *up-to-date* ]]; then
			echo "up to date."
		else
			xgPull=${xgPull//$'\n'/$'\n'   }
		    echo -e "\n   $xgPull"
		fi
	else
		echo -e "\n!> Updating $xgPullBranchName failed!"
		return 1
	fi
}

git_push() {
	xgPushBranchName=${1:?}
	xgDeleteBranchName=$2

	echo ">> Pushing changes..."
	if xgPush=$(git push --set-upstream --tags --porcelain origin $xgPushBranchName $xgDeleteBranchName 2>&1); then
		xgPush=$(echo "$xgPush" | grep -A 100 "^To " | grep "^[^=].*" | grep -v "set up to track remote branch" |  grep -v "Done")
		xgPush=${xgPush//refs\/}
		xgPush=${xgPush//heads\/}
		xgPush=${xgPush//tags\/}
		echo "   $xgPush"
	else
		echo "!> Pushing $xgPushBranchName failed..."
		echo "$xgPush" | grep -A 100 "^To " | grep "^[^=].*" | grep -v "Done" 
		return 1
	fi	
}

git_wd_clean() {
	if [[ -z $(git status -s | grep -v ^??) ]]; then 
		return 0
	else
		return 1
	fi
}

git_transfer() {
	prompt "?> Uncommitted changes detected - would you like to transfer it?" !yes:continue abort:exit1

	git_stash
}

git_stash() {
	git stash --keep-index --quiet
	XG_StashedFlag=true
}

git_transfer_apply() {
	if ${XG_StashedFlag:-false}; then 
		XG_StashedFlag=false
		if git stash pop --quiet; then
			echo ">> Transfer applied."
		else
			git stash drop
			echo "!> Transfer applied, but with conflicts."
			return 1
		fi
	fi 
}

git_version_current() {
	RET=$(git describe --tags --abbrev=0 master)
}

git_version_check() {
	xgVersionToCheck=$1
	if [[ ! -z $(echo $xgVersionToCheck | grep -E "^[0-9]+\.[0-9]+\.[0-9]+$") ]]; then
		RET=$xgVersionToCheck
	elif [[ ! -z $(echo $xgVersionToCheck | grep -E "^[0-9]+\.[0-9]+$") ]]; then
		RET=$xgVersionToCheck.0
	elif [[ ! -z $(echo $xgVersionToCheck | grep -E "^[0-9]+$") ]]; then
		RET=$xgVersionToCheck.0.0
	else
		echo "!> Bad version format."
		exit 1
	fi
}

git_version_bump() {
	xgFullVersionNumber=$1
	xgBumpCode=$2

	xgMaj=${xgFullVersionNumber%%.*}
	xgTail=${xgFullVersionNumber#*.}
	xgMin=${xgTail%%.*}
	xgFix=${xgTail##*.}
	
	xgBumpMaj=${xgBumpCode%%.*}
	xgBumpTail=${xgBumpCode#*.}
	xgBumpMin=${xgBumpTail%%.*}
	xgBumpFix=${xgBumpTail##*.}

	bump_number $xgMaj $xgBumpMaj; xgMaj=$RET
	bump_number $xgMin $xgBumpMin; xgMin=$RET
	bump_number $xgFix $xgBumpFix; xgFix=$RET
	
	RET=$xgMaj.$xgMin.$xgFix
}

bump_number() {
	xgVersionNumber=$1
	xgBumpChar=$2

	case $xgBumpChar in
	+)
		let xgVersionNumber++
		;;
	-)
		if [[ xgVersionNumber != 0 ]]; then
			let xgVersionNumber--	
		fi
		;;
	0)
		xgVersionNumber=0
		;;
	x)
		;;
	esac

	RET=$xgVersionNumber
}

foreach_subrepo() {
	xgDelegate=${1:?}
	xgWorkingDir=$2

	xgGitBranch=$(git branch | grep ^\*)
	xgGitBranch=${xgGitBranch:2}

	xgSubRepos=$(find . -type d -name .git)
	for xgSubRepo in $xgSubRepos; do
		xgRepoPath=${xgSubRepo%/*}
		cd $xgRepoPath

		xgCurrentDir=$(pwd)
		xgRepoName=${xgCurrentDir##*/}

		xgGitBranch=$(git branch | grep ^\*)
		xgGitBranch=${xgGitBranch:2}
		xgHeader="-----[ $xgRepoName : $xgGitBranch ]---------------------------------------------------------"

		# echo "---> $xgRepoPath"
		if $xgDelegate "$xgRepoName" $xgWorkingDir || [[ $xgRepoPath == "." ]]; then
			xgPrintout=$RET
			echo -e "\033[34m${xgHeader::60}\033[00m"
			echo -en "$xgPrintout"
		fi

		cd - > /dev/null
	done
}

# =============================================================================
