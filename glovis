#!/bin/bash

# =====[ GLO VISUAL ]==========================================================
#
#	Written by Francois Joubert
#	Oct 2013
#
#	This lib contains visual glo commit logs.
#
# =============================================================================

lib glovis

# -----[ GIT COMMANDS ]--------------------------------------------------------

# [info-doc visual]
# {BLU}visual <Args>
#   Renders a visual graph of the brances.
glo_visual() {
	COLS_TERM=$(tput cols)
	ROWS_TERM=$(tput lines)

	COLS_GRAPH=25
	let "COLS_BRANCH = COLS_TERM / 6"
	COLS_COMMITTER=5
	COLS_DATE=11
	COLS_SHA=7
	let "COLS_TEXT = COLS_TERM - (COLS_GRAPH + COLS_BRANCH + COLS_COMMITTER + COLS_DATE + COLS_SHA)"

	goto_parent_dir '[[ -d .git ]]'

	# echo "RefHeads"
	unset RefHeads
	for Ref in $(find .git/refs/heads -type f); do
		RefHeads="$RefHeads${Ref#.git/refs/heads/} "
	done

	# echo "Ancestry master"
	MasterShas=$(git rev-list --first-parent master)
	# echo "Ancestry dev"
	DevShas=$(git rev-list --first-parent dev)

	# echo "Branch refs"
	HeadSha=$(git rev-parse HEAD)
	DevSha=$(git rev-parse dev)
	get_refs "$(git branch --list)"; TaskRefs=(${REFS[@]}); TaskShas=${NODES[@]}

	MasterFlag=false
	DevFlag=false
	DanglingBranch=false

	for (( i = 0 ; i < 7 ; i++ )); do
		TaskTrackParent[$i]="x"
		TaskTrackColors[$i]="#RST"
		TaskTrackLinkHds[$i]="xx"
		TaskTrackLinks[$i]="xx"
		TaskTracks[$i]="x"
	done

	# echo "Nodes"
	let "MaxNodes = (ROWS_TERM * 10) / 15"
	NodeList=$(git rev-list --max-count $MaxNodes $RefHeads)
	# NodeList=$(git rev-list $RefHeads)
	for Node in $NodeList; do
		next_tracks

		CommitInfo=$(git show --no-patch --format="%P+++%s+++%an+++%ad" --date=short $Node) # 7ms
		Parents=(${CommitInfo%%+++*}); CommitInfo=${CommitInfo#*+++}
		CommitText=${CommitInfo%%+++*}; CommitInfo=${CommitInfo#*+++}
		initials "${CommitInfo%%+++*}"; CommitInfo=${CommitInfo#*+++}; Committer="$RET"
		CommitDate=${CommitInfo%%+++*};

		# === MASTER ===
		if [[ $MasterShas == *$Node* ]]; then 
			if find_track $Node; then
				DevLinkHd="--"
				close_tracks ${POS[@]} # master spawn type
			fi

			if [[ ${#Parents[@]} > 1 ]]; then
				DevLink="marrow" # may be a task
				DevGraph="|"
				DevFlag=true
			elif [[ ${#Parents[@]} == 0 ]]; then
				DevLink="devpawn"
			else
				DevFlag=false
			fi
		
			Version=$(git describe --tags --abbrev=0 $Node 2>/dev/null)
			if [[ -n $Version ]]; then
				MasterGraph="release"
				Branch="#GRN[$Version]"
			else
				MasterGraph="commit"
				Branch="#RED[novsn]"
			fi
		
			if [[ $Node == $HeadSha ]]; then
				MasterGraph="head"
			fi

			MasterFlag=true

		# === DEV ===
		elif [[ $DevShas == *$Node* ]]; then 
			if find_track $Node; then
				DevGraphHd="|"
				close_tracks ${POS[@]}
			fi
			
			if [[ $Node == $DevSha ]]; then
				Branch="#REDdev"
			fi

			if [[ ${#Parents[@]} > 1 ]]; then
				DevGraph="aommit"
				if find_track ${Parents[1]}; then
					open_track $POS apply
				else
					new_track merge
				fi
			else
				DevGraph="commit"
				Branch="#REDDirty commit $Branch"
			fi

			if [[ $Node == $HeadSha ]]; then
				DevGraph="head"
			fi

			DevFlag=true

		# === TASK ===
		else
			ChangeColorFlag=false # param!
			if get_branchname $Node; then
				Branch=$RET
				ChangeColorFlag=true
				git_branch_gettype $Branch; TaskName=$NAME
				case $TYPE in
					feature)
						TaskTrackColor="#BLU"
						Branch="$TaskTrackColor$TaskName" ;;
					bug)
						TaskTrackColor="#MGN"
						Branch="$TaskTrackColor$TaskName" ;;
					hotfix)
						TaskTrackColor="#MGN"
						Branch="$TaskTrackColor$TaskName" ;;
					*)
						TaskTrackColor="#YLW"
						Branch="$TaskTrackColor$TaskName" ;;
				esac
			fi

			TaskMerge=none # param!
			if [[ ${#Parents[@]} > 1 ]]; then
				if [[ $DevShas == *${Parents[1]}* ]]; then
					TaskMerge=dev
					DevGraph="|"
				else
					TaskMerge=task
					Sha=${Parents[1]}
					Branch="(${Sha::7}) $Branch"
					# if ! find_track...
					new_track taskmrg
				fi
			fi

			if find_track $Node; then 
				set_track $POS ${Parents[0]}
			else
				new_track task
			fi
		fi

		print_tracks
	done
}

get_ancestry() {
	local StartNode=${1:?}
	local Node

	NODES=$StartNode
	Node=$StartNode
	while Node=$(git rev-parse $Node^ 2>/dev/null); do
		NODES="$NODES $Node"
	done
}

get_refs() {
	local Refs=$1
	
	if [[ -n $Refs ]]; then
		REFS=(${Refs//\*/ })
		unset NODES
		
		local Ref
		local i=0
		for Ref in ${REFS[@]}; do
			NODES[$i]=$(git rev-parse $Ref)
			let i++
		done
	else
		unset REFS
		unset NODES
	fi
}

get_branchname() {
	local Node=${1:?}

	[[ -z $TaskShas ]] && return 1

	local i=0
	local Sha
	for Sha in $TaskShas; do 
		if [[ $Sha == $Node ]]; then 
			RET=${TaskRefs[$i]}
			return 0
		fi

		let i++
	done

	return 1
}

initials() {
	local Name=${1:?}
	unset RET

	local Term
	for Term in $Name; do
		RET="$RET${Term::1}"
	done
}

find_track() {
	local Node=${1:?}
	unset POS

	local i
	for (( i = 0 ; i < ${#TaskTracks[@]} ; i++ )); do
		if [[ $Node == ${TaskTrackParent[$i]} ]]; then
			POS="$POS$i "
		fi
	done
	
	[[ -z $POS ]] && return 1
	
	POS=($POS)
}

new_track() {
	local Type=${1:?}

	local i
	for (( i = 0 ; i < ${#TaskTracks[@]} ; i++ )); do
		if [[ ${TaskTracks[$i]} == "x" ]]; then
			# echo "new $Type $i"
			if [[ $Type == task ]]; then
				DanglingBranch=true
				set_track $i ${Parents[0]}
			elif [[ $Type == merge ]]; then
				open_track $i fpply
			else
				TaskTrackParent[$i]=${Parents[1]}
				TaskTracks[$i]="fpply"
			fi

			break
		fi
	done
}

open_track() {
	local Pos=${1:?}
	local Type=${2:?}

	# echo "merge $Type $i"
	TaskTrackLinks[0]="#RSTlarrow"
	# TaskTrackColors[$Pos]="#RST"

	local i
	for (( i = 1 ; i <= $Pos ; i++ )); do
		TaskTrackLinks[$i]="#RST--"
	done

	TaskTrackParent[$Pos]=${Parents[1]}
	TaskTracks[$Pos]=$Type
}

set_track() {
	local Pos=${1:?}
	local Parent=${2:?}

	# echo "set $Type $TaskMerge $Pos"	
	if $ChangeColorFlag; then
		# echo "$TaskTrackColor"
		TaskTrackColors[$Pos]=$TaskTrackColor
	fi
	
	TaskTrackParent[$Pos]=$Parent

	if [[ $Node == $HeadSha ]]; then
		TaskTracks[$Pos]="head"
	else
		if ${DanglingBranch:-false}; then
			TaskTracks[$Pos]="dommit"
			Branch="#RED<-$Branch"
		else
			TaskTracks[$Pos]="commit"
		fi
	fi
	DanglingBranch=false

	if [[ $TaskMerge == dev ]]; then
		TaskTrackLinks[$Pos]="#REDrarrow"
		for (( i = 0 ; i < $Pos ; i++ )); do
			TaskTrackLinks[$i]="#RED--"
		done
	elif [[ $TaskMerge == task ]]; then
		local Pos1 
		let "Pos1=Pos + 1"
		TaskTrackLinks[$Pos1]="tmerge"
		# for (( i = $Pos1 + 1 ; i < ${#TaskTracks[@]} ; i++ )); do
		# 	TaskTrackLinks[$i]="=="
		# done
	fi
}

close_tracks() {
	local Poses=${@:?}
	# echo "close $Poses"

	NeedsHead=true

	local i
	local ArrowFlag=false
	for (( i = ${#TaskTracks[@]} - 1 ; i >= 0 ; i-- )); do
		if [[ $Poses == *$i* ]]; then
			TaskTrackParent[$i]="x"
			TaskTrackHds[$i]="spawn"
			TaskTracks[$i]="x"
			TaskTrackLinkHds[$i]="--"
			ArrowFlag=true
		elif $ArrowFlag; then
			TaskTrackLinkHds[$i]="--"
		fi
	done
}

next_tracks() {
	if $MasterFlag; then 
		MasterGraphHd="|"
		MasterGraph="|"
	else
		MasterGraphHd="x"
		MasterGraph="x"
	fi
	
	if $DevFlag; then 
		DevGraphHd="|"
		DevGraph="|"
	else
		DevGraphHd="x"
		DevGraph="x"
	fi
	
	DevLinkHd="xx"
	DevLink="xx"

	local i
	local Track
	for (( i = 0 ; i < ${#TaskTracks[@]} ; i++ )); do
		TaskTrackLinkHds[$i]="xx"
		TaskTrackHds[$i]="x"
		TaskTrackLinks[$i]="xx"
		Track=${TaskTracks[$i]}
		Track=${Track//head/|}
		Track=${Track//dommit/|}
		Track=${Track//commit/|}
		Track=${Track//fpply/|}
		Track=${Track//apply/|}
		TaskTracks[$i]=$Track
	done

	unset Branch
	NeedsHead=false
}

print_tracks() {
	local TrackHd

	local TrackHds
	local Tracks

	local GraphHd
	local Graph

	local i
	for (( i = 0 ; i < ${#TaskTracks[@]} ; i++ )); do
		if $NeedsHead; then
			if [[ ${TaskTrackHds[$i]} == "spawn" ]]; then
				TrackHd="spawn"
			else
				TrackHd=${TaskTracks[$i]}
				TrackHd=${TrackHd//commit/|}
				TrackHd=${TrackHd//fpply/x}
				TrackHd=${TrackHd//apply/|}
				# TrackHd=${TrackHd//spawn/ }
			fi

			TrackHds="$TrackHds#RED${TaskTrackLinkHds[$i]}${TaskTrackColors[$i]}$TrackHd"
		fi
		
		Tracks="$Tracks${TaskTrackLinks[$i]}${TaskTrackColors[$i]}${TaskTracks[$i]}"
	done



	if $NeedsHead; then
		GraphHd="#GRN$MasterGraphHd#RED$DevLinkHd$DevGraphHd$TrackHds"
		GraphHd=${GraphHd//spawn/\'}
		GraphHd=${GraphHd//x/ }
		format_text "$GraphHd"; GraphHd=$RET
		# echo $TrackHds
		echo -e "$GraphHd"
	fi

	Graph="#GRN$MasterGraph#RED$DevLink$DevGraph$Tracks"
	Graph=${Graph//release/X}
	Graph=${Graph//aommit/O}
	Graph=${Graph//dommit/$}
	Graph=${Graph//commit/o}
	Graph=${Graph//head/@}
	Graph=${Graph//larrow/<-}
	Graph=${Graph//rarrow/->}
	Graph=${Graph//fpply/,}
	Graph=${Graph//apply/|}
	Graph=${Graph//marrow/<=}
	Graph=${Graph//tmerge/<-}
	Graph=${Graph//devpawn/==}
	Graph=${Graph//x/ }

	format_text -w $COLS_GRAPH "$Graph";         Graph=$RET
	format_text -w $COLS_BRANCH "$Branch ";      Branch=$RET
	format_text -w $COLS_TEXT "$CommitText";     CommitText=$RET
	format_text -w $COLS_COMMITTER "$Committer"; Committer=$RET
	
	echo -e "$Graph$Branch$CommitText$CommitDate $Committer${Node::7}"
}
