#!/usr/bin/env bash

# =====[ BASH TEST FRAMEWORK ]=================================================
#
#	Written by Francois Joubert
#	Nov 2013
#
# =============================================================================

source ${0%/*}/../libs/stdlib
import utils

# -----[ RUN ]-----------------------------------------------------------------

sht.run() {
	local SuiteRunList=${@:-all}
	SuiteRunList=":${SuiteRunList// /:}:"

	if [[ ! -d ./test ]]; then
		echo "No test dir found."
		terminate enverr_no_test_dir
	fi

	cd ./test; TestDir=$(pwd)
	__SHTTESTDIR=$TestDir/.test
	local Suites=$(ls *SUITE 2> /dev/null || true)
	if [[ -z $Suites ]]; then
		echo "!> No test suites found."
		terminate enverr_no_tests
	fi

	rm -rf .test; mkdir .test;

	local BaseFunctionList=$(declare -F)

	declare -i SuiteCount=0 SuiteSkipCount=0
	declare -i TestCount=0 TestsSkipCount=0 TestsFailCount=0
	unset TestsResults

	local SuiteArray=($Suites)
	local SuiteCount=${#SuiteArray[@]}
	local SuiteFunctions
	echo "T> Running $SuiteCount suites..."
	echo -e "   - ${Suites//$'\n'/\n   - }"

	for Suite in $Suites; do
		unset -f $SuiteFunctions

		if [[ $SuiteRunList != *:all:* && $SuiteRunList != *:$Suite:* ]]; then
			print -w -d "Skipping $Suite"
			continue
		fi

		cd $TestDir; source $Suite; cd .test
		TestTmpDir=$(pwd)

		local NewFunctionList=$(declare -F)
		local FunctionDiff=$(diff -y --suppress-common-lines <(echo "$BaseFunctionList") <(echo "$NewFunctionList") || true)
		local FunctionDiffLine FunctionName

		local Tests=""
		SuiteFunctions=""
		while read FunctionDiffLine; do
			FunctionName=${FunctionDiffLine#*declare -f }
			SuiteFunctions+="$FunctionName "
			if [[ $FunctionName == test.* ]]; then
				Tests+="$FunctionName "
			fi
		done <<< "$FunctionDiff"

		local FunctionLineNr OrderedTests=""
		shopt -s extdebug
		for Test in $Tests; do
			FunctionLineNr=$(declare -F $Test)
			FunctionLineNr=${FunctionLineNr#* }
			FunctionLineNr=${FunctionLineNr%% *}
			OrderedTests+="$FunctionLineNr:$Test"$'\n'
		done
		shopt -u extdebug
		Tests=""
		OrderedTests=$(echo "$OrderedTests" | sort -n)
		for Test in $OrderedTests; do
			Tests+="${Test#*:} "
		done

		sht.run.header "SUITE $Suite" "\033[34m" 1
		SuiteCount+=1

		SuiteName=${Suite%test_SUITE}
		SuiteName=${SuiteName%testSUITE}
		SuiteName=${SuiteName%SUITE}
		SuiteName=${SuiteName%_}

		SHT_ErrorStatus=success
		$SuiteName.init_suite
		InitSuiteExitCode=$?

		if [[ $InitSuiteExitCode != 0 || $SHT_ErrorStatus != success ]]; then
			SuiteSkipCount+=1
			echo -e "\033[31m"
			echo "Initializer init_suite terminated with a non-zero exit code!"
			echo "Suite: $Suite"
			echo "Code:  $InitSuiteExitCode"
			echo -e "\033[00m"
			continue
		fi

		SuiteTestDir=$(pwd)

		for Test in $Tests; do
			cd $SuiteTestDir
			SHT_TestResult=pass

			let "TestNumber = TestCount + 1" || true
			sht.run.header "TEST $TestNumber: $SuiteName.$Test" "\033[36m"

			SHT_ErrorStatus=success
			$SuiteName.init_test
			InitTestExitCode=$?

			if [[ $InitTestExitCode != 0 || $SHT_ErrorStatus != success ]]; then
				sht.run.record_result $TestCount $Test skipped
				echo -e "\033[31m"
				echo "Initializer init_test terminated with a non-zero exit code!"
				echo "Test: $Test"
				echo "Code: $InitTestExitCode"
				echo -e "\033[00m"
				continue
			fi

			SHT_ErrorStatus=success
			STD_TraceFile="$TestTmpDir/$SuiteName.$Test.trace"
			$Test
			local TestExitCode=$?

			if [[ ${SHT_TestResult} == pass ]]; then
				TestStatus=passed
				echo -en "\033[32m"
				echo -n "PASS"
				echo -e "\033[30m"
			elif [[ ${SHT_TestResult} == assert_failed ]]; then
				TestStatus=failed
				echo -e "\033[31m"
				echo "FAILED - An assert failed!"
				echo "Test: $Test"
				echo -e "\033[00m"
			elif [[ ${TestExitCode} == 0 ]]; then
				TestStatus=failed
				echo -e "\033[31m"
				echo "FAILED - An unisolated error occured!"
				echo "Test: $Test"
				echo -e "\033[00m"
			else
				TestStatus=failed
				echo -e "\033[31m"
				echo "FAILED - Test terminated with a non-zero exit code!"
				echo "Test: $Test"
				echo "Code: $TestExitCode"
				echo -e "\033[00m"
			fi

			SHT_ErrorStatus=success
			$SuiteName.end_test
			EndTestExitCode=$?

			if [[ $EndTestExitCode != 0 || $SHT_ErrorStatus != success ]]; then
				if [[ $TestStatus == passed ]]; then
					TestStatus=endfail
				fi
				echo -e "\033[31m"
				echo "End end_test terminated with a non-zero exit code!"
				echo "Test: $Test"
				echo "Code: $EndTestExitCode"
				echo -e "\033[00m"
			fi

			sht.run.record_result $TestCount $SuiteName.$Test $TestStatus
		done

		SHT_ErrorStatus=success
		$SuiteName.end_suite
		EndSuiteExitCode=$?

		if [[ $EndSuiteExitCode > 0 || $SHT_ErrorStatus != success ]]; then
			echo -e "\033[31m"
			echo "End end_suite terminated with a non-zero exit code!"
			echo "Suite: $Suite"
			echo "Code:  $EndSuiteExitCode"
			echo -e "\033[00m"
		fi
	done

	sht.run.header "RESULTS" "\033[34m" 1; echo

	for TestsResult in "${TestsResults[@]}"; do
		echo -e "  $TestsResult"
	done
	echo -e "\033[00m"

	if [[ $TestCount > 0 ]]; then
		if [[ $SuiteSkipCount == 0 && $TestsFailCount == 0 && $TestsSkipCount == 0 ]]; then
			echo -e "\033[32m  ALL PASSED!"
		else
			if [[ $SuiteSkipCount > 0 ]]; then
				echo -e "\033[35m  $SuiteSkipCount of $SuiteCount suites SKIPPED."
			fi
			if [[ $TestsFailCount != 0 ]]; then
				echo -e "\033[31m  $TestsFailCount of $TestCount tests FAILED."
			fi
			if [[ $TestsSkipCount != 0 ]]; then
				echo -e "\033[35m  $TestsSkipCount of $TestCount tests SKIPPED."
			fi
		fi
		echo -en "\033[00m"
	else
		echo -e "\033[31m  No tests ran.\033[00m"
	fi

	sht.run.header "END" "\033[34m" 1; echo
}

sht.run.record_result() {
	local Index=${1:?}
	local Name=${2:?}
	local Status=${3:?}

	local Color
	case $Status in
		passed)
			Color="\033[32m" ;;
		failed)
			Color="\033[31m"
			TestsFailCount+=1 ;;
		skipped)
			Color="\033[35m"
			TestsSkipCount+=1 ;;
		endfail)
			Color="\033[35m" ;;
	esac
	TestsResults[$Index]="$Color$Status  $Name"

	let "TestCount = $Index + 1" || true
}

sht.run.header() {
	local Title=${1:?}
	echo -en "$2"
	local Level=${3:-2}
	local Header
	case $Level in
		1) Header="=====[ $Title ]=================================================================" ;;
		2) Header="-------[ $Title ]---------------------------------------------------------------" ;;
		3) Header="- - - - -[ $Title ]- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -" ;;
		3) Header="- - - - - -[ $Title ]-" ;;
	esac
	Header=${Header:0:70}
	echo; echo "$Header"
	echo -en "\033[00m"
}

sht.run.check_sig_int() {
	local ErrorCode=$1

	if [[ $ErrorCode == 130 ]]; then
		kill $!
		terminate interrupted
	fi
}

# -----[ ISOLATION AND ERROR ]-------------------------------------------------

isolate() {
	local Command="$@"

	trap 'isolate.handle_error $? $BASH_COMMAND' ERR

	# Var values like __STDErrorType, set in command is lost because of the fork
	local ExitCode=0
	$Command &
	wait $! || ExitCode=$?

	if [[ $ExitCode == 0 ]]; then
		SHT_ErrorStatus=success
	elif [[ $ExitCode == 200 ]]; then
		SHT_ErrorStatus=exception
	else
		SHT_ErrorStatus=error
	fi

	sht.trap_error
}

isolate.handle_error() {
	local ErrorCode=$1; shift || true
	local CmdLine=$@

	echo "T> Isolated ERROR [$ErrorCode] at: $CmdLine"

	exit 200
}

sht.trap_error() {
	trap 'sht.handle_error $? $BASH_COMMAND' ERR
}

sht.handle_error() {
	# echo ${FUNCNAME[@]}
	if [[ ${FUNCNAME[1]} != sht.run ]]; then
		std.handle_error "$@"
	fi

	SHT_ErrorStatus=error
	SHT_TestResult=error
}

# -----[ ASSERT ]--------------------------------------------------------------

assert_success() {
	# catch; local ExitCode=$RET
	local ExitCode=$?

	if [[ $ExitCode == 0 && $SHT_ErrorStatus == success ]]; then
		sht.assert_passed "success"
	elif [[ $ExitCode != 0 ]]; then
		sht.assert_failed "success" "error code=$ExitCode"
	else
		sht.assert_failed "success" "$SHT_ErrorStatus"
	fi
}

assert_error() {
	local ErrorType=${1:-any_error}

	if [[ $SHT_ErrorStatus != success ]] && [[ $ErrorType == any_error || $SHT_ErrorStatus == $ErrorType ]]; then
		sht.assert_passed "error $ExitCode"
	else
		sht.assert_failed $ErrorType $SHT_ErrorStatus
	fi

	SHT_ErrorStatus=success
}

assert_expr() {
	terminate syserr_not_impl
}

assert_equal() {
	local Value="${1:-null}"
	local Expected="${2:-null}"

	debug "assert_equal: $Value"

	if [[ "$Value" == "$Expected" ]]; then
		sht.assert_passed "$Value = $Expected"
	else
		sht.assert_failed "$Expected" "$Value"
	fi
}

fail_test() {
	local Expected="${1:-null}"
	local Actual="${2:-null}"

	sht.assert_failed "$Expected" "$Actual"
}

sht.assert_passed() {
	echo -en "\033[34m"
	echo -n "Assert $@: "
	echo -en "\033[32m"
	echo -n "PASS"
	echo -e "\033[30m"
}

sht.assert_failed() {
	local Expected="${1:-null}"
	local Actual="${2:-null}"

	echo -en "\033[31m"
	echo "Assert FAILED!"
	echo "Test: ${FUNCNAME[2]}:${BASH_LINENO[1]}"
	echo "Expt: $Expected"
	echo -n "Actl: $Actual"
	echo -e "\033[00m"

	SHT_TestResult=assert_failed
}

# -----[ MAIN ]----------------------------------------------------------------

__STDTerminateOnError=false
sht.trap_error

export STD_TraceMode=true
export STD_TraceFile

sht.run $@

terminate ok

# =============================================================================
